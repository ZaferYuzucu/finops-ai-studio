/**
 * üõ°Ô∏è ADMIN-ONLY DIAGNOSTICS & ERROR LOG SYSTEM
 * 
 * Kullanƒ±cƒ± hi√ßbir ≈üey hissetmez.
 * Sistem asla durmaz.
 * Admin her ≈üeyi g√∂rebilir.
 */

import { collection, addDoc, serverTimestamp } from 'firebase/firestore';
import { db } from '../../firebase';

export type DiagnosticEventType =
  | 'CSV_PARSE_WARNING'
  | 'CONFIDENCE_LOW'
  | 'DASHBOARD_FALLBACK'
  | 'RUNTIME_ERROR'
  | 'ASSUMPTION_BLOCKED'
  | 'DATA_QUALITY_ISSUE';

export interface DiagnosticEvent {
  id?: string; // Auto-generated by Firestore
  userId?: string;
  email?: string;
  eventType: DiagnosticEventType;
  dashboardId?: string;
  fileId?: string;
  confidenceScore?: number;
  riskFlags?: Array<{
    code: string;
    severity: 'low' | 'medium' | 'high' | 'critical';
    message: string;
  }>;
  message: string;
  metadata?: Record<string, any>; // Ek bilgiler
  createdAt?: any; // serverTimestamp
}

/**
 * üõ°Ô∏è Sessiz log atma - UI etkilenmez
 */
export async function logDiagnosticEvent(event: Omit<DiagnosticEvent, 'id' | 'createdAt'>): Promise<void> {
  try {
    // Firestore'a yaz: /diagnostics/events/{logId}
    await addDoc(collection(db, 'diagnostics', 'events'), {
      ...event,
      createdAt: serverTimestamp(),
    });
    
    // Dev mode'da console'a da yaz (admin i√ßin)
    if (import.meta.env.DEV) {
      console.group('üî¨ [Diagnostics]', event.eventType);
      console.log('Message:', event.message);
      if (event.confidenceScore !== undefined) {
        console.log('Confidence:', (event.confidenceScore * 100).toFixed(0) + '%');
      }
      if (event.riskFlags && event.riskFlags.length > 0) {
        console.log('Risk Flags:', event.riskFlags.length);
      }
      console.groupEnd();
    }
  } catch (error) {
    // üõ°Ô∏è Firestore yazƒ±lamazsa sessizce atla - UI etkilenmez
    if (import.meta.env.DEV) {
      console.warn('‚ö†Ô∏è [Diagnostics] Log yazƒ±lamadƒ± (sessizce atlandƒ±):', error);
    }
    // UI etkilenmez, sistem √ßalƒ±≈ümaya devam eder
  }
}

/**
 * CSV parse warning log
 */
export async function logCSVParseWarning(
  userId: string | undefined,
  email: string | undefined,
  fileId: string | undefined,
  warnings: string[],
  confidenceScore?: number
): Promise<void> {
  await logDiagnosticEvent({
    userId,
    email,
    fileId,
    eventType: 'CSV_PARSE_WARNING',
    message: `CSV parse uyarƒ±larƒ±: ${warnings.slice(0, 3).join(', ')}`,
    confidenceScore,
    metadata: { warnings },
  });
}

/**
 * Low confidence log
 */
export async function logLowConfidence(
  userId: string | undefined,
  email: string | undefined,
  dashboardId: string | undefined,
  confidenceScore: number,
  riskFlags?: DiagnosticEvent['riskFlags']
): Promise<void> {
  await logDiagnosticEvent({
    userId,
    email,
    dashboardId,
    eventType: 'CONFIDENCE_LOW',
    message: `Dashboard g√ºven skoru d√º≈ü√ºk: %${Math.round(confidenceScore * 100)}`,
    confidenceScore,
    riskFlags,
  });
}

/**
 * Dashboard fallback log
 */
export async function logDashboardFallback(
  userId: string | undefined,
  email: string | undefined,
  dashboardId: string,
  reason: string
): Promise<void> {
  await logDiagnosticEvent({
    userId,
    email,
    dashboardId,
    eventType: 'DASHBOARD_FALLBACK',
    message: `Dashboard fallback modda render edildi: ${reason}`,
  });
}

/**
 * Runtime error log
 */
export async function logRuntimeError(
  userId: string | undefined,
  email: string | undefined,
  error: Error,
  context?: Record<string, any>
): Promise<void> {
  await logDiagnosticEvent({
    userId,
    email,
    eventType: 'RUNTIME_ERROR',
    message: error.message || 'Bilinmeyen runtime hatasƒ±',
    metadata: {
      errorName: error.name,
      errorStack: error.stack,
      context,
    },
  });
}

/**
 * Assumption blocked log
 */
export async function logAssumptionBlocked(
  userId: string | undefined,
  email: string | undefined,
  fileId: string | undefined,
  blockedAssumptions: string[]
): Promise<void> {
  await logDiagnosticEvent({
    userId,
    email,
    fileId,
    eventType: 'ASSUMPTION_BLOCKED',
    message: `${blockedAssumptions.length} varsayƒ±m engellendi`,
    metadata: { blockedAssumptions },
  });
}

/**
 * Data quality issue log
 */
export async function logDataQualityIssue(
  userId: string | undefined,
  email: string | undefined,
  fileId: string | undefined,
  issue: string,
  metadata?: Record<string, any>
): Promise<void> {
  await logDiagnosticEvent({
    userId,
    email,
    fileId,
    eventType: 'DATA_QUALITY_ISSUE',
    message: issue,
    metadata,
  });
}
